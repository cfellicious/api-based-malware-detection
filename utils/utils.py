import os
import shutil
import zipfile
from utils.constants import (BUCKET_NAME, TEMP_DIR, TEMP_PATH, DATA_DIR, API_CALL_FILE_NAME,
                             XML_FILE_NAME, LABEL_FILE_PATH, CALL_DICT_PATH)


def convert_labels(malware_families):
    inverse_mapping = dict()
    label_dict = dict()
    idx = 0
    for family, shas in malware_families.items():
        for sha in shas:
            labels = label_dict.get(sha, [])
            labels.append(idx)
            label_dict[sha] = labels
        inverse_mapping[idx] = family
        idx += 1

    return label_dict, idx, inverse_mapping


def write_results(y_true, y_pred, file_name='complete_results.json', transformed=False, inverse_mapping=dict()):
    import json
    import numpy as np
    from sklearn.preprocessing import MultiLabelBinarizer

    if transformed is False:
        mlb = MultiLabelBinarizer()
        rand_mat = np.random.randint(low=0, high=len(y_pred[0]), size=(255, 15))
        mlb.fit_transform(rand_mat)
        predicted_labels = mlb.inverse_transform(y_pred)
        true_labels = mlb.inverse_transform(y_true)
    else:
        true_labels = y_true
        predicted_labels = y_pred

    common_predicted_count = 0
    total_true_labels = 0
    total_predicted_labels = 0
    missed_true_count = 0
    imprecise_pred_count = 0
    missed_true_dict = dict()
    imprecise_pred_dict = dict()

    for idx in range(len(predicted_labels)):
        curr_true = set(true_labels[idx])
        curr_pred = set(predicted_labels[idx])
        common = curr_true.intersection(curr_pred)
        common_predicted_count += len(list(common))
        curr_missed = list(curr_true.difference(curr_pred))
        curr_imprecise = list(curr_pred.difference(curr_true))

        missed_true_count += len(curr_missed)
        imprecise_pred_count += len(curr_imprecise)

        for miss in curr_missed:
            miss = int(miss)
            miss_count = missed_true_dict.get(miss, 0)
            missed_true_dict[inverse_mapping.get(miss, miss)] = miss_count + 1

        for impr in curr_imprecise:
            impr = int(impr)
            impr_count = imprecise_pred_dict.get(impr, 0)
            imprecise_pred_dict[inverse_mapping.get(impr, impr)] = impr_count + 1

        total_predicted_labels += len(predicted_labels[idx])
        total_true_labels += len(true_labels[idx])

    complete_dict = dict()
    complete_dict['total_true'] = total_true_labels
    complete_dict['total_predicted'] = total_predicted_labels
    complete_dict['common_predicted'] = common_predicted_count
    complete_dict['missed_true_count'] = missed_true_count
    complete_dict['imprecise_prediction_count'] = imprecise_pred_count
    complete_dict['imprecise_prediction_dict'] = imprecise_pred_dict
    complete_dict['missed_prediction_dict'] = missed_true_dict
    print(missed_true_dict)
    print(imprecise_pred_dict)
    with open(file_name, 'w') as fp:
        fp.write(json.dumps(complete_dict, indent=4))


def get_data(client, file, prefix='train'):

    if not isinstance(file, str):
        sha = file.object_name.split(sep='/')[1].split(sep='-')[0]
    else:
        sha = file

    path = os.path.join(DATA_DIR, sha)
    if not os.path.exists(path=path + '.json'):
        get_file_from_minio(client=client, path=path, file=file)

    with open(path + '.json', 'r') as fp:
        return fp.readlines()


def get_file_from_minio(client, file, path):
    t = client.fget_object(bucket_name=BUCKET_NAME,
                           object_name=file.object_name,
                           file_path=TEMP_PATH)

    assert (zipfile.is_zipfile(TEMP_PATH))
    with zipfile.ZipFile(TEMP_PATH, 'r') as zip_ref:
        zip_ref.extractall(TEMP_DIR)

    shutil.copy(os.path.join(TEMP_DIR, API_CALL_FILE_NAME), path + '.jsonl')
    shutil.copy(os.path.join(TEMP_DIR, XML_FILE_NAME), path + '.xml')
    #  shutil.copy('./temp_data/apiTracing.txt', path + '.jsonl')
    #  shutil.copy('./temp_data/inMemoryResults.xml', path + '.xml')


def get_train_test_files(client, train_files_count, test_file_percentage=0.25, random_state=42,
                         use_local_files_only=False, single_label_only=True):
    import utils.constants
    from sklearn.model_selection import train_test_split

    if use_local_files_only is True:
        all_files = os.listdir(DATA_DIR)
        files = [x[:-5] for x in all_files if '.json' in x]

    else:
        files = list(client.list_objects(utils.constants.BUCKET_NAME, '', recursive=True))
        files = [x for x in files if '.json' not in x.object_name]
    print('Total Files:%d' % len(files))

    if single_label_only is True:
        single_label_files = []
        label_dict, _, _ = get_label_mapping_dict()
        for file in files:
            if isinstance(file, str):
                sha = file
            else:
                sha = file.object_name.split(sep='-')[0]
                sha = sha.split(sep='/')[1]
            if len(label_dict.get(sha)) == 1:
                single_label_files.append(file)
        files = single_label_files
    
    test_size = int(train_files_count * test_file_percentage)
    train_files, test_files = train_test_split(files, random_state=random_state, test_size=test_file_percentage)
    train_files = train_files[:train_files_count]
    test_files = test_files[:test_size]

    return train_files, test_files


def get_label_mapping_dict():
    import json
    with open(LABEL_FILE_PATH, 'r') as fp:
        malware_families = json.load(fp)
    label_dict, max_label, inverse_mapping = convert_labels(malware_families=malware_families)
    return label_dict, max_label, inverse_mapping


def get_call_dict():
    import json
    with open(CALL_DICT_PATH, 'r') as fp:
        call_dict = json.load(fp=fp)

    return call_dict



